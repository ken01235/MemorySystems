#define CRC_KIT
#ifndef UTILS_H
#define UTILS_H

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// This file is distributed as part of the Cache Replacement Championship     //
// workshop held in conjunction with ISCA'2010.                               //
//                                                                            //
//                                                                            //
// Everyone is granted permission to copy, modify, and/or re-distribute       //
// this software.                                                             //
//                                                                            //
// Please contact Aamer Jaleel <ajaleel@gmail.com> should you have any        //
// questions                                                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE ---
// --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE ---
// --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE ---

// IMPORTANT NOTE: DO NOT CHANGE ANYTHING IN THIS HEADER FILE. Changing anything
// in here will violate the competition rules.

#include <string>
#include <iostream>
using namespace std;

#ifdef CRC_KIT 

#define UINT32      unsigned int
#define INT32       int
#define ADDRINT     unsigned long long
#define COUNTER     unsigned long long
#define BITVECTOR   unsigned long long
#define Addr_t      unsigned long long

#else


#define BITVECTOR   unsigned long long
#define Addr_t      unsigned long long
#endif

// Works by finding position of MSB set.
static inline INT32 CRC_FloorLog2(UINT32 n)
{
    INT32 p = 0;

    if (n == 0) return -1;

    if (n & 0xffff0000) { p += 16; n >>= 16; }
    if (n & 0x0000ff00) { p +=  8; n >>=  8; }
    if (n & 0x000000f0) { p +=  4; n >>=  4; }
    if (n & 0x0000000c) { p +=  2; n >>=  2; }
    if (n & 0x00000002) { p +=  1; }

    return p;
}

// Works by finding position of MSB set.
// @returns -1 if n == 0.
static inline INT32 CRC_CeilLog2(UINT32 n)
{
    return CRC_FloorLog2(n - 1) + 1;
}

#endif

#ifndef CRC_CACHE_DEFS_H
#define CRC_CACHE_DEFS_H

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// This file is distributed as part of the Cache Replacement Championship     //
// workshop held in conjunction with ISCA'2010.                               //
//                                                                            //
//                                                                            //
// Everyone is granted permission to copy, modify, and/or re-distribute       //
// this software.                                                             //
//                                                                            //
// Please contact Aamer Jaleel <ajaleel@gmail.com> should you have any        //
// questions                                                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE ---
// --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE ---
// --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE --- DO NOT EDIT THIS FILE ---

// IMPORTANT NOTE: DO NOT CHANGE ANYTHING IN THIS HEADER FILE. Changing anything
// in here will violate the competition rules.

typedef struct
{
    bool        valid;       // Is line valid?
    Addr_t      tag;         // Tag of line
    bool        dirty;       // Is line dirty?
    BITVECTOR   sharing_dir; // Directory of which core accessed this line
} LINE_STATE;

typedef enum 
{
    ACCESS_IFETCH      = 0,
    ACCESS_LOAD        = 1,
    ACCESS_STORE       = 2,
    ACCESS_UNSUPPORT0  = 3,
    ACCESS_UNSUPPORT1  = 4,
    ACCESS_PREFETCH    = 5,
    ACCESS_WRITEBACK   = 6,
    ACCESS_MAX         = 7
} AccessTypes;

#define IS_STORE(X)  (X == ACCESS_STORE || X == ACCESS_WRITEBACK);

#endif
#ifndef REPL_STATE_H
#define REPL_STATE_H

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// This file is distributed as part of the Cache Replacement Championship     //
// workshop held in conjunction with ISCA'2010.                               //
//                                                                            //
//                                                                            //
// Everyone is granted permission to copy, modify, and/or re-distribute       //
// this software.                                                             //
//                                                                            //
// Please contact Aamer Jaleel <ajaleel@gmail.com> should you have any        //
// questions                                                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <cstdlib>
#include <cassert>

// Replacement Policies Supported
typedef enum  {

    SCHEDULER_FCFS   = 0,
    SCHEDULER_FRFCFS = 1,
    SCHEDULER_PARBS  = 2

} SchedulerPolicy;

typedef struct {

    int serial;
    int process;
    int bank;
    int row;
    bool del;

    // Only for PARBS
    bool mark;
    bool hit;

} QUEUE_STATE;

typedef struct {

    int timer;
    bool start;
    int serial;
    int process;
    int bank;
    int row;
    int mark;

    // Only for PARBS
    int * Marks; // recording the left mark 
    int * ProcessLoad;

} BANK_STATE;


// The implementation for the cache replacement policy
class SCHEDULER_STATE {

  private:
    int processes;
    int banks;
    int policy;
    int queue_size;
    int hit_latency;
    int miss_latency;
    int marking_cap;

    int mytimer;  // tracks # of references to the cache
    int queue_len;
    
    BANK_STATE * Banks;
    QUEUE_STATE * Queue;

    // Only for PARBS
    int * MaxBankLoad; // calculated accroding to ProcessLoad in Banks (per process)
    int * TotalLoad; // (per process)
    int * sorted_processes;

  public:

    // The constructor CAN NOT be changed
    SCHEDULER_STATE( int _processes, int _banks, int _policy, int _queue_size, int _hit_latency, int _miss_latency, int _marking_cap );

    bool is_full();
    void AddRequest( int serial, int process, int bank, int row );
    char* RequestString( char* s, int serial, int process, int bank, int row );
    bool Update();
    bool UpdateFCFS();
    bool UpdateFRFCFS();
    bool UpdatePARBS();
    void UpdateMarksAndLoads();
    ostream& PrintStats( ostream &out );

  private:
    
    void Init();
    void to_string( char *s, int i, int len );
    
    // Only for PARBS
    int FindBest( int bank );
    int BestHit( int bank, int mark_cnt, int *marked_requests );
    int BestRank( int bank, int hit_cnt, int *hit_requests );

};


#endif
#include <stdio.h> 
#include <stdlib.h> 

SCHEDULER_STATE::SCHEDULER_STATE( int _processes, int _banks, int _policy, int _queue_size, int _hit_latency, int _miss_latency, int _marking_cap )
{
    Banks = new BANK_STATE[ _banks ];
    Queue = new QUEUE_STATE[ _queue_size ];
    MaxBankLoad = new int[ _processes ];
    TotalLoad = new int[ _processes ];
    sorted_processes = new int [ _processes ];

    processes = _processes;
    banks = _banks;
    policy = _policy;
    queue_size = _queue_size;
    hit_latency = _hit_latency;
    miss_latency = _miss_latency;
    marking_cap = _marking_cap;

    mytimer = 0;
    queue_len = 0;

    Init();
}

void SCHEDULER_STATE::Init()
{
    for ( int i = 0; i < banks; i++ ) {
        Banks[ i ].timer = -2;
        Banks[ i ].mark = 1;
        Banks[ i ].start = 0;
        Banks[ i ].row = -1;
        Banks[ i ].Marks = new int[ processes ];
        Banks[ i ].ProcessLoad = new int[ processes ];
        for ( int j = 0; j < processes; j++ ) {
            Banks[ i ].Marks[ j ] = marking_cap;
            Banks[ i ].ProcessLoad[ j ] = 0;
        }
    }

    for ( int i = 0; i < processes; i++ ) {
        MaxBankLoad[ i ] = 0;
        TotalLoad[ i ] = 0;
        sorted_processes[ i ] = processes - i - 1;
    }

    return;
}

bool SCHEDULER_STATE::is_full()
{
    return queue_len == queue_size;
}

ostream & SCHEDULER_STATE::PrintStats( ostream &out )
{

    char s[20];
    for ( int i = 0; i < banks; i++ ) {
        if ( Banks[ i ].start ) {
            out << RequestString( s, Banks[ i ].serial, Banks[ i ].process, Banks[ i ].bank, Banks[ i ].row );
        } else if ( Banks[ i ].timer > 0 ) {
            out << "   |              |";
        } else if ( Banks[ i ].timer == 0 ) {
            out << "    -------------- ";
        } else {
            out << "                   ";
        }
    }

    // for ( int i = 0; i < queue_len; i++ )
    //     out << " No." << i << ": (" << Queue[ i ].serial <<' '<< Queue[ i ].process<<' '<<Queue[ i ].bank<<' '<<Queue[ i ].row<<' '<<Queue[ i ].mark<<')';

    return out;
}

void SCHEDULER_STATE::AddRequest( int serial, int process, int bank, int row )
{
    // cout << "In AddRequest\n";
    for ( int i = queue_len; i > 0; i-- ) {
        Queue[ i ].serial  = Queue[ i - 1 ].serial;
        Queue[ i ].process = Queue[ i - 1 ].process;
        Queue[ i ].bank    = Queue[ i - 1 ].bank;
        Queue[ i ].row     = Queue[ i - 1 ].row;
        Queue[ i ].del     = Queue[ i - 1 ].del;
        Queue[ i ].mark    = Queue[ i - 1 ].mark;
        Queue[ i ].hit     = Queue[ i - 1 ].hit;
    }
    Queue[ 0 ].serial  = serial;
    Queue[ 0 ].process = process;
    Queue[ 0 ].bank    = bank;
    Queue[ 0 ].row     = row;
    Queue[ 0 ].del     = 0;
    Queue[ 0 ].mark    = 0;
    Queue[ 0 ].hit     = 0;
    queue_len++;

    return;
}

void SCHEDULER_STATE::to_string ( char *s, int i, int len )
{
    for ( int j = 0; j < len; j++ )
        s[j] = ' ';

    if ( i >= 0 && i < 10 ) {
        s[0] = '0' + i;
    } else if ( i >= 10 && i < 100 ) {
        s[0] = '0' + (i / 10);
        s[1] = '0' + (i % 10);
    } else if ( i >= 100 && i < 1000 ) {
        s[0] = '0' + ((i / 100) % 10);
        s[1] = '0' + ((i / 10) % 10);
        s[2] = '0' + (i % 10);
    } else {
        s[0] = '0' + ((i / 1000) % 10);
        s[1] = '0' + ((i / 100) % 10);
        s[2] = '0' + ((i / 10) % 10);
        s[3] = '0' + (i % 10);
    }
}

char* SCHEDULER_STATE::RequestString( char* s, int serial, int process, int bank, int row )
{
    // cout << "RequestString start\n";
    for ( int i = 0; i < 19; i++ )
        s[i] = ' ';

    s[3] = 't';
    to_string(s + 4, serial, 5);
    s[9] = 'P';
    to_string(s + 10, process, 2);
    s[12] = 'B';
    to_string(s + 13, bank, 2);
    s[15] = '(';
    to_string(s + 16, row, 2);
    s[18] = ')';
    s[19] = '\0';
    return s;
}

bool SCHEDULER_STATE::Update()
{
    if ( policy == SCHEDULER_FCFS )
        return UpdateFCFS();
    else if ( policy == SCHEDULER_FRFCFS )
        return UpdateFRFCFS();
    else if ( policy == SCHEDULER_PARBS )
        return UpdatePARBS();
}

bool SCHEDULER_STATE::UpdateFCFS()
{
    for ( int i = 0; i < queue_len; i++ ) {
        if ( Queue[ i ].del ) {
            for ( int j = i--; j <= queue_len - 1; j++ ) {
                Queue[ j ].serial  = Queue[ j + 1 ].serial;
                Queue[ j ].process = Queue[ j + 1 ].process;
                Queue[ j ].bank    = Queue[ j + 1 ].bank;
                Queue[ j ].row     = Queue[ j + 1 ].row;
                Queue[ j ].del     = Queue[ j + 1 ].del;
            }
            queue_len--;
        }
    }

    for ( int i = 0; i < banks; i++ ) {
        if ( Banks[ i ].timer > 0 ) {
            Banks[ i ].start = 0;
        }
        Banks[ i ].timer--;

        if ( Banks[ i ].timer < 0 ) {
            int j = queue_len - 1;
            while ( j >= 0  && Queue[ j ].bank != i ) j--;
            if ( j >= 0 ) {
                Banks[ i ].timer = ( Banks[ i ].row == Queue[ j ].row )? hit_latency - 1: miss_latency - 1;
                Banks[ i ].start = 1;
                Banks[ i ].serial  = Queue[ j ].serial;
                Banks[ i ].process = Queue[ j ].process;
                Banks[ i ].bank    = Queue[ j ].bank;
                Banks[ i ].row     = Queue[ j ].row;

                Queue[ j ].del = 1;
            }
        }
    }
    bool finish = queue_len > 0;
    for ( int i = 0; i < banks; i++ ) {
        finish = finish || Banks[ i ].timer >= 0;
    }
    return finish;
}

bool SCHEDULER_STATE::UpdateFRFCFS()
{
    for ( int i = 0; i < queue_len; i++ ) {
        if ( Queue[ i ].del ) {
            for ( int j = i--; j <= queue_len - 1; j++ ) {
                Queue[ j ].serial  = Queue[ j + 1 ].serial;
                Queue[ j ].process = Queue[ j + 1 ].process;
                Queue[ j ].bank    = Queue[ j + 1 ].bank;
                Queue[ j ].row     = Queue[ j + 1 ].row;
                Queue[ j ].del     = Queue[ j + 1 ].del;
                Queue[ j ].hit     = Queue[ j + 1 ].hit;
                Queue[ j ].mark    = Queue[ j + 1 ].mark;
            }
            queue_len--;
        }
    }

    for ( int i = 0; i < banks; i++ ) {
        if ( Banks[ i ].timer > 0 ) {
            Banks[ i ].start = 0;
        }
        Banks[ i ].timer--;

        if ( Banks[ i ].timer < 0 ) {
            int j = queue_len - 1;
            while ( j >= 0  && ( Queue[ j ].bank != i || Queue[ j ].row != Banks[ i ].row ) ) j--;
            if ( j >= 0 ) {

                Banks[ i ].timer = ( Banks[ i ].timer == -1 && Banks[ i ].row == Queue[ j ].row )? hit_latency - 1: miss_latency - 1;
                Banks[ i ].start = 1;
                Banks[ i ].serial  = Queue[ j ].serial;
                Banks[ i ].process = Queue[ j ].process;
                Banks[ i ].bank    = Queue[ j ].bank;
                Banks[ i ].row     = Queue[ j ].row;

                Queue[ j ].del = 1;

            } else {

                j = queue_len - 1;
                while ( j >= 0  && Queue[ j ].bank != i ) j--;
                if ( j >= 0 ) {
                    Banks[ i ].timer = ( Banks[ i ].timer == -1 && Banks[ i ].row == Queue[ j ].row )? hit_latency - 1: miss_latency - 1;
                    Banks[ i ].start = 1;
                    Banks[ i ].serial  = Queue[ j ].serial;
                    Banks[ i ].process = Queue[ j ].process;
                    Banks[ i ].bank    = Queue[ j ].bank;
                    Banks[ i ].row     = Queue[ j ].row;

                    Queue[ j ].del = 1;
                }

            }
        }
    }

    bool finish = queue_len > 0;
    for ( int i = 0; i < banks; i++ ) {
        finish = finish || Banks[ i ].timer >= 0;
    }
    return finish;
}

bool SCHEDULER_STATE::UpdatePARBS()
{
    // cout << "In UpdatePARBS\n";
    for ( int i = 0; i < queue_len; i++ ) {
        if ( Queue[ i ].del ) {
            for ( int j = i--; j <= queue_len - 1; j++ ) {
                Queue[ j ].serial  = Queue[ j + 1 ].serial;
                Queue[ j ].process = Queue[ j + 1 ].process;
                Queue[ j ].bank    = Queue[ j + 1 ].bank;
                Queue[ j ].row     = Queue[ j + 1 ].row;
                Queue[ j ].del     = Queue[ j + 1 ].del;
                Queue[ j ].hit     = Queue[ j + 1 ].hit;
                Queue[ j ].mark    = Queue[ j + 1 ].mark;
            }
            queue_len--;
        }
    }
    UpdateMarksAndLoads();

    for ( int i = 0; i < banks; i++ ) {

        if ( Banks[ i ].timer > 0 ) {
            Banks[ i ].start = 0;
        }
        Banks[ i ].timer = Banks[ i ].timer >= -1? Banks[ i ].timer - 1: -2;

        for ( int j = 0; j < queue_size; j++ ) {
            Queue[ j ].hit = ( Queue[ j ].bank == i ) && ( Banks[ i ].row == Queue[ j ].row );
        }


        if ( Banks[ i ].timer < 0 ) {
            // find the best request in queue
            int best_request = FindBest( i );
            if ( best_request >= 0 ) {
                Banks[ i ].timer = ( /*Banks[ i ].timer == -1 &&*/ Banks[ i ].row == Queue[ best_request ].row )? hit_latency - 1: miss_latency - 1;
                Banks[ i ].start = 1;
                Banks[ i ].serial  = Queue[ best_request ].serial;
                Banks[ i ].process = Queue[ best_request ].process;
                Banks[ i ].bank    = Queue[ best_request ].bank;
                Banks[ i ].row     = Queue[ best_request ].row;
                Banks[ i ].mark    = Queue[ best_request ].mark;

                Queue[ best_request ].del = 1;
            }
        }
    }

    bool finish = queue_len > 0;
    for ( int i = 0; i < banks; i++ ) {
        finish = finish || Banks[ i ].timer >= 0;
    }
    return finish;
}

int SCHEDULER_STATE::FindBest( int bank )
{
    // cout << "In FindBest\n";
    int mark_cnt = 0;
    int marked_requests[ queue_len ];
    for ( int i = 0; i < queue_len; i++ ) {
        if ( ( Queue[ i ].bank == bank ) && Queue[ i ].mark == true )
            marked_requests[ mark_cnt++ ] = i;
    }
    if ( mark_cnt == 1 )
        return marked_requests[ 0 ];
    else
        return BestHit( bank, mark_cnt, marked_requests );
}

int SCHEDULER_STATE::BestHit( int bank, int mark_cnt, int *marked_requests )
{
    // cout << "In BestHit\n";
    int hit_cnt = 0;
    int hit_requests[ queue_len ];
    if ( mark_cnt == 0 ) {
        for ( int i = 0; i < queue_len; i++ ) {
            if ( ( Queue[ i ].bank == bank ) && Queue[ i ].hit )
                hit_requests[ hit_cnt++ ] = i;
        }
    } else {
        for ( int i = 0; i < mark_cnt; i++ ) {
            if ( Queue[ marked_requests[ i ] ].hit )
                hit_requests[ hit_cnt++ ] = marked_requests[ i ];
        }
    }

    if ( hit_cnt == 1 )
        return hit_requests[ 0 ];
    else if ( hit_cnt > 1 )
        return BestRank( bank, hit_cnt, hit_requests );
    else if ( hit_cnt == 0 && mark_cnt > 0 )
        return BestRank( bank, mark_cnt, marked_requests );
    else
        return BestRank( bank, 0, hit_requests ) ;
}

int SCHEDULER_STATE::BestRank( int bank, int hit_cnt, int *hit_requests )
{
    // cout << "In BestRank\n";

    int ans;
    int process;
    if ( hit_cnt > 0 ) {
        for ( int i = 0; i < processes; i++ ) {
            process = sorted_processes[ i ];
            ans = hit_cnt - 1;
            while ( ans >= 0 && Queue[ hit_requests[ ans ] ].process != process ) ans--;
            if ( ans >= 0 ) return hit_requests[ ans ];
        }
    } else {
        for ( int i = 0; i < processes; i++ ) {
            process = sorted_processes[ i ];
            ans = queue_len - 1;
            while ( ans >= 0 && ( Queue[ ans ].bank != bank || Queue[ ans ].process != process ) ) ans--;
            if ( ans >= 0 ) return ans;
        }
    }
    return ans;
}

void SCHEDULER_STATE::UpdateMarksAndLoads()
{
    // cout << "In UpdateMarksAndLoads\n";
    bool rst = 1;
    int bank, process;
    for ( int i = 0; i < queue_len; i++ ) {
        rst = (rst && !Queue[ i ].mark);
    }

    if ( !rst ) return;

    for ( int i = 0; i < processes; i++ ) {
        MaxBankLoad[ i ] = 0;
        for ( int j = 0; j < banks; j++ ) {
            Banks[ j ].Marks[ i ] = marking_cap;
        }
    }
    for ( int i = queue_len - 1; i >= 0; i-- ) {
        bank = Queue[ i ].bank;
        process = Queue[ i ].process;
        if ( !Queue[ i ].mark && Banks[ bank ].Marks[ process ] ) {
            Banks[ bank ].Marks[ process ]--;
            TotalLoad[ process ]++;
            Queue[ i ].mark = 1;

            if ( MaxBankLoad[ process ] < (marking_cap - Banks[ bank ].Marks[ process ]) )
                MaxBankLoad[ process ]++;
        }
    }

    int min_max_bank_load = marking_cap * banks + 1;
    int prev_min_max_bank_load = -1;
    int min_process_cnt = 0;
    int min_processes[ processes ];
    int min_process_cnt_2 = 0;
    int min_processes_2[ processes ];
    for ( int i = 0; i < processes; ) {
        for ( int j = 0; j < processes; j++ ) {
            if ( MaxBankLoad[ j ] < min_max_bank_load && MaxBankLoad[ j ] > prev_min_max_bank_load ) {
                min_max_bank_load = MaxBankLoad[ j ];
                min_process_cnt = 1;
                min_processes[ 0 ] = j;
            } else if ( MaxBankLoad[ j ] == min_max_bank_load && MaxBankLoad[ j ] > prev_min_max_bank_load ) {
                min_processes[ min_process_cnt++ ] = j;
            }
        }
        if ( min_process_cnt == 1 ) {
            sorted_processes[ i++ ] = min_processes[ 0 ];
        } else {
            int tmp = min_process_cnt;
            int sum_total_load = 1;
            int min_total_load;
            int prev_min_total_load = -1;
            for ( int j = 0; j < processes; j++ ) {
                sum_total_load += TotalLoad[ j ];
            }
            min_total_load = sum_total_load;
            while ( tmp ) {
                for ( int j = 0; j < min_process_cnt; j++ ) {
                    if ( TotalLoad[ min_processes[ j ] ] < min_total_load && TotalLoad[ min_processes[ j ] ] > prev_min_total_load ) {
                        min_total_load = TotalLoad[ min_processes[ j ] ];
                        min_process_cnt_2 = 1;
                        min_processes_2[ 0 ] = min_processes[ j ];
                    } else if ( TotalLoad[ min_processes[ j ] ] == min_total_load && TotalLoad[ min_processes[ j ] ] > prev_min_total_load ) {
                        min_processes_2[ min_process_cnt_2++ ] = min_processes[ j ];
                    }
                }
                tmp -= min_process_cnt_2;
                while ( min_process_cnt_2-- ) sorted_processes[ i++ ] = min_processes_2[ min_process_cnt_2 ];
                prev_min_total_load = min_total_load;
                min_total_load = sum_total_load;
                min_process_cnt_2 = 0;
            }
        }

        prev_min_max_bank_load = min_max_bank_load;
        min_max_bank_load = marking_cap * banks + 1;
        min_process_cnt = 0;
    }
    // cout << " sorted_processes: ";
    // for ( int i = 0; i < processes; i++ )
    //     cout << sorted_processes[ i ];
    // cout << " MaxBankLoad: ";
    // for ( int i = 0; i < processes; i++ )
    //     cout << MaxBankLoad[ i ];
    // cout << " TotalLoad: ";
    // for ( int i = 0; i < processes; i++ )
    //     cout << TotalLoad[ i ];
}

#include <iostream>
#include <functional>
using namespace std;

int main()
{
    int timer = 0;
    bool finish = 0;
    char s[20];

    int processes, banks, queue_size, policy, hit_latency, miss_latency, marking_cap, T;
    cin >> processes >> banks >> queue_size >> policy >> hit_latency >> miss_latency >> marking_cap >> T;
    cout << processes << "\n";
    cout << banks << "\n";
    cout << queue_size << "\n";
    cout << policy << "\n";
    cout << hit_latency << "\n";
    cout << miss_latency << "\n";
    cout << marking_cap << "\n";
    cout << T << "\n";

    SCHEDULER_STATE * scheduler = new SCHEDULER_STATE( processes, banks, policy, queue_size, hit_latency, miss_latency, marking_cap );

    while (!finish) {
        int serial, process, bank, row;

        // remove reqs that 'del'=1 from queue (batch--)
        // if the current batch is cleaned: generate new batch, update loads and rank
        // DRAM take reqs from queue and set 'del'=1
        // check it's finished or not. if not, read in and print out the input
        cout.width(4);
        cout << left << timer++;
        scheduler->Update();
        if ( scheduler->is_full() ) {
            cout << "                   ";
            scheduler->PrintStats( cout );
            cout << "\n";
        } else {
            cin >> serial >> process >> bank >> row;
            cout << scheduler->RequestString( s, serial, process, bank, row );
            scheduler->AddRequest( serial, process, bank, row );
            scheduler->PrintStats( cout );
            cout << "\n";
        }

        finish = serial == T - 1;
    }

    while ( scheduler->Update() ) {
        cout.width(4);
        cout << left << timer++;
        cout << "                   ";
        scheduler->PrintStats( cout );
        cout << "\n";
    }

    delete scheduler;

    return 0;

}
